<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ice Note</title>
  <subtitle>笔记</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.zeesuu.com/"/>
  <updated>2016-03-03T02:45:24.000Z</updated>
  <id>http://www.zeesuu.com/</id>
  
  <author>
    <name>兰斌</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Javascript继承</title>
    <link href="http://www.zeesuu.com/2016/03/01/js%E7%BB%A7%E6%89%BF/"/>
    <id>http://www.zeesuu.com/2016/03/01/js继承/</id>
    <published>2016-03-01T06:44:00.000Z</published>
    <updated>2016-03-03T02:45:24.000Z</updated>
    
    <content type="html">&lt;p&gt;Javascript的继承一直都是一个世纪大难题,主要是因为在Javascript中所有的数据类型都是对象,但是没有类的概念.&lt;br&gt;虽然现在ES6中已经可以开始使用class关键字,但是离大面积使用还是有段距离.而且在文档中,class关键字并非是一种新的创建对象的方式,它只是一种更清晰/方便的创建类和继承的语法.&lt;/p&gt;
&lt;h2 id=&quot;理解prototype&quot;&gt;&lt;a href=&quot;#理解prototype&quot; class=&quot;headerlink&quot; title=&quot;理解prototype&quot;&gt;&lt;/a&gt;理解prototype&lt;/h2&gt;&lt;p&gt;Javascript的起源是用作简单的网页交互.但是由于其数据类型都是对象,所以需要用继承将所有的对象关联起来.那么有了对象要创建实例就引入了new命令.  &lt;/p&gt;
&lt;p&gt;但是new命令会将构造函数中的所有数据都全部创造一个副本,这样一些公用的属性和方法就会随着实例的增多而耗费更多的资源&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Sth&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.pro_one = &lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.fun_one = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; sth_one = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Sth()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; sth_two = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Sth()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sth_one.fun_one != sth_two.fun_one &lt;span class=&quot;comment&quot;&gt;//false, 因为在实例化的时候开辟两个内存区域&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;所以为了解决这个问题,引入了prototype.&lt;br&gt;有了prototype,大家开始建议这样书写&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Sth&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.pro_one = &lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Sth.prototype.fun_one = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;prototype属性是一个对象,存放的是所有实例对象需要共享的属性和方法.&lt;br&gt;其实相当于构造函数里面的属性和方法分了两种,一种在构造函数里在this下自己拥有,一种在prototype上共享使用的.&lt;/p&gt;
&lt;h2 id=&quot;理解继承&quot;&gt;&lt;a href=&quot;#理解继承&quot; class=&quot;headerlink&quot; title=&quot;理解继承&quot;&gt;&lt;/a&gt;理解继承&lt;/h2&gt;&lt;p&gt;理解继承有两个主要的属性&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Sth&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; sth = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Sth()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//sth.prototype 原型对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//sth.construct (指向Sth)此属性指向其构造函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;原型链继承&quot;&gt;&lt;a href=&quot;#原型链继承&quot; class=&quot;headerlink&quot; title=&quot;原型链继承&quot;&gt;&lt;/a&gt;原型链继承&lt;/h4&gt;&lt;p&gt;继承就是需要子类要拥有父类的属性和方法,原型继承的方式就是在子类定义了自己的属性和方法之后,再将父类的属性和方法放在子类的公共区域,可以供子类的所有的实例进行使用,那么按照上方说的方法,就是讲父类的实例要放在子类的prototype中,形如&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Sup&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.age = &lt;span class=&quot;number&quot;&gt;45&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//父类中的prototype对象中所有的属性和方法可以看做是public,而在构造函数中的属性和方法则是private&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Sup.prototype.getAge = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.age&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Sub&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.age = &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//将父类的属性和方法放在子类的公共区域&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Sub.prototype = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Sup() &lt;span class=&quot;comment&quot;&gt;//Sub.prototype为Sup的一个实例,其construct指向的为Sup&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//假如此时创建一个实例&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//var sub = new Sub()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//实例的construct对象也会指向Sup,这明显是有问题的,所以需要手动将此属性指回来再创建实例&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//console.log(sub.construct) //显示 Sup&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Sub.prototype.construct = Sub&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;参考:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;阮一峰的网络日志 - Javascript继承机制的设计思想&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Javascript的继承一直都是一个世纪大难题,主要是因为在Javascript中所有的数据类型都是对象,但是没有类的概念.&lt;br&gt;虽然现在ES6中已经可以开始使用class关键字,但是离大面积使用还是有段距离.而且在文档中,class关键字并非是一种新的创建对象的方式,
    
    </summary>
    
      <category term="javascript" scheme="http://www.zeesuu.com/categories/javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>关于面试</title>
    <link href="http://www.zeesuu.com/2016/03/01/%E5%85%B3%E4%BA%8E%E9%9D%A2%E8%AF%95/"/>
    <id>http://www.zeesuu.com/2016/03/01/关于面试/</id>
    <published>2016-03-01T05:51:00.000Z</published>
    <updated>2016-03-01T06:18:32.000Z</updated>
    
    <content type="html">&lt;hr&gt;
&lt;p&gt;来到ENJOY之后,由于人员的问题开始大量接手面试的工作.&lt;br&gt;在互联网的”寒冬”中,一些公司撑不到下一轮融资,一些工程师开始寻求新的机会.&lt;br&gt;简历如大雪纷飞,虽然多,但是合格的却乏善可陈.  &lt;/p&gt;
&lt;p&gt;对于职位要求不明确,是我遇到的最明显的一个问题.&lt;br&gt;求职意向都写的是前端工程师,但是简历里面有一半都是和前端工作经验没有关系.&lt;br&gt;令我惊讶的是, 几乎有一大半的工程师都是从java转过来的.&lt;br&gt;问其原因大多都是当时公司需要一个前端而已. &lt;/p&gt;
&lt;p&gt;现在前端的轮子很多,新的概念工具层出不穷,大多数转行的工程师都是从直接使用轮子(Jquery,Bootstrap)开始.&lt;br&gt;这其实没有什么问题,但是在觉得深入这一行之后,还是要对于其基础的东西进行了解.&lt;/p&gt;
&lt;p&gt;经常在和面试者交谈的时候,大概几句话就能知道对方的知识结构.&lt;br&gt;针对不同的层次,我会选择不同的问题.  &lt;/p&gt;
&lt;p&gt;用原生Javascript来开发一款游戏是我最喜欢问的.&lt;br&gt;因为这个游戏涉及到了几乎涉及到了Javascript的交互/动画/DOM操作/数据处理,&lt;br&gt;在游戏布局和运行过程中也不可避免的涉及到了css/html.&lt;br&gt;几乎可以从全方位来考察面试者对于前端基础知识的掌握程度.&lt;br&gt;但是现在能够大概回答出来的人寥寥无几, 更多人的回答像是产品需求文档描述,而不是实现过程的描述.  &lt;/p&gt;
&lt;p&gt;几个月下来,让我感觉到有些疲惫.&lt;br&gt;希望下次能遇到不错的工程师.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a href=&quot;http://enjoy.ricebook.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ENJOY&lt;/a&gt;北京需要前端工程师,简历可以发至lanbin1987#gmail.com&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;来到ENJOY之后,由于人员的问题开始大量接手面试的工作.&lt;br&gt;在互联网的”寒冬”中,一些公司撑不到下一轮融资,一些工程师开始寻求新的机会.&lt;br&gt;简历如大雪纷飞,虽然多,但是合格的却乏善可陈.  &lt;/p&gt;
&lt;p&gt;对于职位要求不明确,是我遇到的最明显的一个问题.
    
    </summary>
    
      <category term="工作" scheme="http://www.zeesuu.com/categories/%E5%B7%A5%E4%BD%9C/"/>
    
    
      <category term="面试" scheme="http://www.zeesuu.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
</feed>
